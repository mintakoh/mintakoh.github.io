
---
layout: post
title:  "토비의 스프링 1장 정리"
date:   2019-01-26 18:40:00
author: Mintak OH
categories: 스프링
tags: spring java toby
---

# 1장. 오브젝트와 의존관계
 &nbsp; &nbsp; 스프링은 자바를 기반으로 한 기술이다. 자바에서 가장 중요하게 가치를 두는 것은 객체지향 프로그래밍이 가능한 언어라는 점이다. 스프링의 핵심 철학은 자바 엔터프라이즈 기술의 혼란 속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고, 그로부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이다. 
 &nbsp; &nbsp;  객체지향 설계의 기초와 원칙을 비롯해서, 다양한 목적을 위해 재활용 가능한 설계 방법인 디자인 패턴, 좀 더 깔끔한 구조가 되도록 지속적으로 개선해나가는 작업인 리팩토링, 오브젝트가 기대한 대로 동작하고 있는지를 효과적으로 검증하는 데 쓰이는 단위 테스트와 같은 오브젝트 설계와 구현에 관한 여러 가지 응용 기술과 지식이 요구된다. 
 
## 1.1 초난감 DAO
### 1.1.1 User
 &nbsp; &nbsp; 사용자 정보를 저장할 때는 자바빈 규약을 따르는 오브젝트를 이용하면 편리하다. 
* 자바빈
    자바빈(JavaBean)은 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말한다. JSP 빈, EJB와 같은 표준 기술과 자바빈 스타일의 오브젝트를 사용하는 오픈소스 기술을 통해 계속 이어져 왔다.
	*	디폴트 생성자: 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 리플렉션을 이용해 오브젝트를 생성하기 때문이다.
	*	프로퍼티: 자바빈이 노출하는 이름을 가진 속성이다. setter와 getter를 이용해 수정 또는 조회할 수 있다. 

### 1.1.2 UserDao
  &nbsp; &nbsp;사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스다. 사용자 정보를 관리하는 DAO이고, 사용자 정보의 등록, 수정, 삭제와 각종 조회 기능을 만들어야 한다. 
* 동작 확인 방법
	* DAO의 기능을 사용하는 웹 애플리케이션을 만들어 서버에 배치하고 사용해 보는 것이다. (부담이 너무 크다.)

### 1.1.3 main()을 이용한 DAO 테스트 코드
 &nbsp; &nbsp;기능을 검증하고자 할 때 사용할 수 있는 가장 간단한 방법은 오브젝트 스스로 자신을 검증하도록 만들어주는 것이다. 테스트 코드가 실패했다면 DB설정과 Connection 정보, 테이블 등록 여부 등을 확인해본다. 사용할 DB의 드라이버가 클래스패스에 있어야 하는 것도 잊으면 안된다. 

## 1.2 DAO의 분리
### 1.2.1 관심사의 분리
 &nbsp; &nbsp; 객체지향 기술은 흔히 실세계를 최대한 가깝게 모델링해낼 수 있기 때문에 의미가 있다고 여겨진다. 하지만 그보다는 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는 데 더 의미가 있다. 
  &nbsp; &nbsp; 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일아난다는 뜻이다. 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 점이다. 변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다. 즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다. 

### 1.2.2 커넥션 만들기의 추출
 &nbsp; &nbsp; DB 커넥션을 가져오는 코드가 여기저기에 계속 중복돼서 나타날 것이다. 하나의 관심사가 방만하게 중복되어 있고, 여기저기 흩어져 있어서 다른 관심의 대상과 얽혀 있으면, 변경이 일어날 때 엄청난 고통을 일으키는 원인이 된다. 
#### 변경사항에 대한 검증: 리팩토링과 테스트
 * 리팩토링
	 * 리팩토링은 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. 리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다. 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이해지고, 견고하면서도 유연한 제품을 개발할 수 있다. 

### 1.2.3 DB 커넥션 만들기의 독립
#### 상속을 통한 확장
 &nbsp; &nbsp; 메소드의 구현 코드를 제거하고 추상 메소드로 만든다. 기존에는 같은 클래스에 다른 메소드로 분리됐던 DB 커넥션 연결이라는 관심을 이번에는 상송을 통해 서브클래스로 분리해버리는 것이다. 
  &nbsp; &nbsp; 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 **템플릿 메소드 패턴** 이라고 한다.  이는 스프링에서 애용되는 디자인 패턴이다. 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴** 이라고 부르기도 한다. 

* 디자인 패턴
	* 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말하낟. 디자인 패턴은 주로 객체지향 설계에 관한 것이고, 대부분 객체 지향적 설계 원칙을 이용해 문제를 해결한다. 

* 템플릿 메소드 패턴
	* 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다. 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다. 슈퍼클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다. 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 **훅 메소드**라고 한다. 

* 팩토리 메소드 패턴
	* 슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있따. 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 **팩토리 메소드**라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 **팩토리 메소드 패턴**이라고 한다. 
 &nbsp; &nbsp; 이 방법은 상속을 사용했다는 단점이 있다. 상속 자체는 간단해 보이고 사용하기도 편리하게 느껴지지만 사실 많은 한계점이 있다. 자바는 클래스의 다중상소긍ㄹ 허용하지 않는다. 또 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다는 것이다. 

## 1.3 DAO의 확장
 &nbsp; &nbsp; 관심사에 따라서 분리한 오브젝트들은 제각기 독특한 변화의  특징이 있다. 변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다. 관심사가 바뀌면 그때 변경이 일어난다. 
  &nbsp; &nbsp; 추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서다. 여전히 상속이라는 방법을 사용했다는 사실이 불편하다. 
### 1.3.1 클래스의 분리
 &nbsp; &nbsp; 관심사가 다르고 변화의 성격이 다른 것을 독립시키면서 동시에 손쉽게 확장할 수 있는 방법을 알아보자. 다르게 변할 수 있는 관심사를 분리하는 작업을 점진저긍로 진행해왔다. 처음에는 독립된 메소드를 만들어서 분리했고, 다음에는 상하위 클래스로 분리했다. 서브클래스가 아니라 아예 별도의 클래스에 담는 방법으로 클래스를 분리한다. 
  &nbsp; &nbsp; 이 방법으로 클래스를 분리하면 상속을 통해 DB 커넥션 기능을 확장해서 사용하던 것이 다시 불가능해졌다. 클래스를 분리한 경우에도 상속을 이용했을 때와 마찬가지로 자유로운 확장이 가능하게 하려면 두 가지 문제를 해결해야 한다.
   * makeNewConnectino()을 사용해 DB 커넥션을 가져오게 했는데, 다른 프로젝트에서 openConnetion()이라는 이름의 메소드를 사용하면 UserDao 내에 있는 코드를 다 변경해야 한다. 
   * DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다는 점이다. 

### 1.3.2 인터페이스의 도입
&nbsp; &nbsp; 클래스를 분리하면서도 이런 문제를 해결할 수 없을까? 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것이다. 인터페이스는 자신을 구현한 클래스에 대해 구체적인 정보는 모두 감춰버린다. 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다. 
&nbsp; &nbsp; 인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이다. 따라서 인터페이스에는 어떻게 하겠다는 구현 방법은 나타나 있지 않다. 

### 1.3.3 관계설정 책임의 분리
&nbsp; &nbsp; UserDao 변경 없이는 DB커넥션 기능의 확장이 자유롭지 못한데, 그 이유는 UserDao 안에 분리되지 않은, 또 다른 관심사항이 존재하고 있기 때문이다. UserDao가 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지를 결정하는 것에 관심사를 담고 있다. 
&nbsp; &nbsp; 클래스 사이에 관계가 만들어진다는 것은 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻이다. 클래스가 아니라 오브젝트와 오브젝트 사이의 관계를 설정해줘야 한다. 오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다. 
&nbsp; &nbsp; 외부에서 만든 오브젝트를 전달받으려면 메소드 파라미터나 생성자 파라미터를 이용하면 된다. 이때 파라미터의 타입을 전달받을 오브젝트의 인터페이스로 선언해뒀다고 해보자, 이런 경우 파라미터로 전달되는 오브젝트의 클래스는 해당 인터페이스를 구현하기만 했다면 어떤 것이든지 상관없다. 

### 1.3.4 원칙과 패턴
#### 개방 폐쇄 원칙
&nbsp; &nbsp; 지금까지 해온 리팩토링 작업의 특징과 최종적으로 개선된 설계와 코드의 장점이 무엇인지 효과적으로 설명할 수 있다. 개방 폐쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. '클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야 한다'라고 정의할 수 있다. 
* 객체지향 설계 원칙(SOLID)
	* SRP(The Single Responsibility Principle): 단일 책임 원칙
	* OCP(The Open Closed Principle): 개방 폐쇄 원칙
	* LSP(The Liskov Substitution Principle): 리스코프 치환 원칙
	* ISP(The Interface Segregation Principle): 인터페시으 분리 원칙
	* DIP(The Dependency Inversion Principle): 의존관계 역전 원칙

#### 높은 응집도와 낮은 결합도
&nbsp; &nbsp; 개방 폐쇄 원칙은 **높은 응집도**와 **낮은 결합도**라는 소프트웨어 개발의 고전적인 원리로도 설명이 가능하다. 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 
##### 높은 응집도
&nbsp; &nbsp; 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명ㅎ라 수도 있다. 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있다. 
##### 낮은 결합도
&nbsp; &nbsp; 낮은 결합도는 높은 응집도보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다. 느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다. 결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다.
&nbsp; &nbsp; 여기에서 결합도란 '하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도'라고 설명할 수 있다. 낮은 결합도란 결국, 하나의 변경이 발생할 때 마치 파문이 이는 것처럼 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 말한다. 

#### 전략 패턴
&nbsp; &nbsp; 전략 패턴은 디자인 패턴의 꽃이라고 불릴 만큼 다양하게 자주 사용되는 패턴이다. 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴이라고 볼 수 있다. 전략 패턴은 자신의 기능 맥락에서, 필요에 다라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다. 

## 1.4 제어의 역전(IoC)
&nbsp; &nbsp; IoC라는 약자로 많이 사용되는 제어의 역전이라는 용어가 있다. 스프링을 통해 일반 개발자에게는 많이 알려진 용어이지만, 상당히 오래전부터 있던 개념이다. 
### 1.4.1 오브젝트 팩토리
#### 팩토리
&nbsp; &nbsp; 분리시킬 기능을 담당할 클래스를 하나 만들어보겠다. 이 클래스의 역할은 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것인데, 이런 일을 하는 오브젝트를 흔히 **팩토리**라고 부른다. 이는 디자인 패턴에서 말하는 특별한 문제를 해결하기 위해 사용되는 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다르니 혼동하지 말자. 단지 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용하는 것이다. 
#### 설계도로서의 팩토리
&nbsp; &nbsp; UserDao와 ConnectionMaker는 각각 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하고 있고, DaoFactory는 이런 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있음을 알 수 있다. 전자가 실질적인 로직을 담당하는 컴포넌트라면, 후자는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할을 한다고 볼 수 있다. 

### 1.4.2 오브젝트 팩토리의 활용
&nbsp; &nbsp; 오브젝트 생성 코드가 중복되는 건 좋지 않은 현상이다. DAO가 많아지면 ConnectionMaker의 구현 클래스를 바꿀 때 마다 모든 메소드를 일일이 수정해야 하기 때문이다. 중복 문제를 해결하려면 역시 분리해내는 게 가장 좋은 방법이다. 
### 1.4.3 제어권의 이전을 통한 제어관계 역전
&nbsp; &nbsp; 제어의 역전이라는 건 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다. 일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 시점에서 다음에 사용할 오브젝트를 결정하고, 결정한 오브젝트를 생서앟고, 만들어진 오브젝트에 있는 메소드를 호출하고, 그 오브젝트 메소드 안에서 다음에 사용할 것을 결정하고 호출하는 식의 작업이 반복된다. 
&nbsp; &nbsp; 제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 또 자신이 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 ㅈ제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다. 
&nbsp; &nbsp; 서블릿을 생각해보자. 일반적인 자바 프로그램은 main() 메소드에서 시작해서 개발자가 미리 정한 순서를 따라 오브젝트가 생성되고 실행된다. 그런데 서블릿을 개발해서 서버에 배포할 수는 있지만, 그 실행을 개발자가 직접 제어할 수 있는 방법은 없다. 서블릿 안에 main() 메소드가 있어서 직접 실행시킬 수 있는 것도 아니다. 대신 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다. 템플릿 메소드는 제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴이라고 볼 수 있다. 
&nbsp; &nbsp;  프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다. 프레임워크는 라이브러리의 다른 이름이 아니다. 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다. 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다. 

## 1.5 스프링의 IoC
### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
#### 애플리케이션 컨텍스트와 설정정보
&nbsp; &nbsp; 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 **빈**이라고 부른다. 자바빈 또는 엔터프라이즈 자바빈에서 말하는 빈과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트를 말한다. 동시에 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다. 
&nbsp; &nbsp;  스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 **빈 팩토리**라고 부른다. 뒤에서 자세히 설명하겠지만 보통 빈 팩토리보다는 이를 좀 더 확장한 **애플리케이션 컨텍스트**를 주로 사용한다. 

#### DaoFactory를 사용하는 애플리케이션 컨텍스트
&nbsp; &nbsp; 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 @Configuration이라는 애노테이션을 추가한다. 그리고 오브젝트를 만들어 주는 메소드에는 @Bean이라는 애노테이션을 붙여준다. 이 두 가지 애노테이션만으로 스프링 프레임워크의 빈 팩토리 또는 애플리케이션 컨텍스트가 IoC 방식의 기능을 제공할 때 사용할 완벽한 설정정보가 된 것이다. 

### 1.5.2 애플리케이션 컨텍스트의 동작방식
&nbsp; &nbsp; 오브젝트 팩토리에 대응되는 것이 스프링의 애플리케이션 컨텍스트이다. 스프링에서는 이 애플리케이션 컨텍스트를 IoC 컨테이너라 하기도 하고, 간단히 스프링 컨테이너라고 부르기도 한다. 또는 빈 팩토리라고 부를 수도 있다. @Configuration이 붙은 DaoFactory는 이 애플리케이션 컨텍스트가 활용하는 IoC 설정정보다. 애플리케이션 컨텍스트는 DaoFactory 클래스를 설정정보로 등록해두고 @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다. 

* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
* 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
* 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다. 

### 1.5.3 스프링 IoC의 용어 정리
* 빈
	* 스프링이 IoC 방식으로 관리하는 오브젝트
* 빈 팩토리
	* 스프링의 IoC를 담당하는 핵심 컨테이너
* 애플리케이션 컨텍스트
	* 빈 팩토리를 확장한 IoC 컨테이너. 빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일하다. 
* 설정정보/설정 메타정보
	* 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다. 
* 컨테이너 또는 IoC 컨테이너
	* IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다. 
* 스프링 프레임워크
	* IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말하는 것이다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프
* 오브젝트의 동일성과 동등성
	* 두 개의 오브젝트가 동일하다면 사실은 하나의 오브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐이다. 두 개의 오브젝트가 동일하지는 않지만 동등한 경우에는 두 개의 각기 다른 오브젝트가 메모리상에 존재하는 것인데, 오브젝트의 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단하는 것일 뿐이다. 물론 동일한 오브젝트는 동등하기도 할 것이다. 하지만 반대는 항상 참은 아니다. 

스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
&nbsp; &nbsp; 애플리케이션 컨텍스트는 우리가 만들었던 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너다. 그러면서 동시에 이 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 **싱글톤 레지스트리**이기도 하다. 

#### 서버 애플리케이션과 싱글톤
&nbsp; &nbsp; 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문에 싱글톤으로 빈을 만든다. 

* 싱글톤 패턴
	* GoF가 소개한 디자인 패턴 중의 하나다. 디자인 패턴 중에서 가장 자주 활용되는 패턴이기도 하지만 가장 많은 비판을 받는 패턴이기도 하다. 싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다. 

#### 싱글톤 패턴의 한계
* private 생성자를 갖고 있기 때문에 상속할 수 없다.
	* 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다. 
* 싱글톤은 테스트하기 힘들다.
	* 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다. 
* 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
* 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.

#### 싱글톤 레지스트리
&nbsp; &nbsp; 스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것은 적극 지지한다. 하지만 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그걸이 바로 **싱글톤 레지스트리**다. 

### 1.6.2 싱글톤과 오브젝트의 상태
&nbsp; &nbsp; 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 **무상태**방식으로 만들어져야 한다. 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 **상태유지**방식으로 만들지 않는다. 상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나 DB나 서버의 리소스로부터 생성한 정보는 파라미터와 로컬 변수, 리턴 값 등을 이용하면 된다. 메소드 파라미터나, 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다. 

### 1.6.3 스프링 빈의 스코프
&nbsp; &nbsp; 스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위를 **빈의 스코프**라고 한다. 스프링 빈의 기본 스코프는 싱글톤이다. 경우에 따라서는 싱글톤 외의 스코프를 가질 수 있다. 대표적으로 **프로토타입 스코프**가 있다. 
* 요청 스코프
	* HTTP 요청이 생길때마다 생성된다.
* 세션 스코프
	* 웹의 세션과 스코프가 유사하다

## 1.7 의존관계 주입(DI)
### 1.7.1 제어의 역전(IoC)과 의존관계 주입
&nbsp; &nbsp; 
* 의존관계 주입, 의존성 주입, 의존 오브젝트 주입?
	* 'Dependency Injection'은 여러 가지 우리말로 번역된다. 그중에서 가장 흔히 사용되는 용어가 **의존성 주입**이다. 의존성이라는 말은 DI의 의미가 무엇인지 잘 드러내주지 못한다. DI는 오브젝트 레퍼런스를 외부로부터 제공받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심이다. '의존관계 설정'이라는 용어도 나쁘지 않다고 생각한다.

### 1.7.2 런타임 의존관계 설정
#### 의존관계
&nbsp; &nbsp;  두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다. 의존한다는 건 의존대상에 영향을 미친다는 뜻이다. 

#### UserDAO의 의존관계
&nbsp; &nbsp; 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다. 결합도가 낮다고 설명할 수 있다. 
&nbsp; &nbsp; 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계 말고, 런타임 시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 런타임 의존관계 또는 오브젝트 의존관계인데, 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다. 런타임 의존관계는 모델링 시점의 의존관계와는 성격이 분명히 다르다. 프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 **의존 오브젝트**라고 말한다. 
&nbsp; &nbsp; 의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업을 말한다.
* 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
* 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
* 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다. 

#### UserDao의 의존관계 주입
&nbsp; &nbsp; DaoFactory는 두 오브젝트 사이의 런타임 의존관계를 설정해주는 의존관계 주입 작업을 주도하는 존재이며, 동시에 IoC 방식으로 오브젝트의 생성과 초기화, 제공등의 작업을 수행하는 컨테이너다. 의존관계 주입을 담당하는 컨테이너라고 볼 수 있고, 줄여서 DI 컨테이너라고 불러도 된다. 보통 DI는 그 근간이 되는 개념인 IoC와 함께 사용해서 IoC/DI 컨테이너라는 식으로 함께 사용하기도 한다. 

### 1.7.3 의존 관계 검색과 주입
&nbsp; &nbsp; 스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다. 코드에서는 구체적인 클래스에 의존하지 않고, 런타임 시에 의존관계를 결정한다는 점에서 의존관계 주입과 비슷하지만, 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 **의존관계 검색**이라고 불리는 것도 있다. 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 
&nbsp; &nbsp; 의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 있다. IoC 원칙에도 잘 들어맞는다. 의존관계 주입 쪽이 훨씬 단순하고 깔끔하다. 스프링의 IoC와 DI 컨테이너를 적용했다고 하더라도 애플리케이션의 기동시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다. main()에서는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다. 서버에서도 마찬가지다. 

### 1.7.4 의존관계 주입의 응용
&nbsp; &nbsp; 객체지향 설계와 프로그래밍의 원칙을 따랐을 때 얻을 수 있는 장점이 그대로 DI 기술에도 적용될 것이다. 코드에는 런타임 클래스에 대한 의존관계가 나타나지 않고, 인터페이스를 통해 결합도가 낮은 코드를 만드므로, 다른 책임을 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장 방법에는 자유롭다는게 지금까지의 장점이다. 
#### 기능 구현의 교환
&nbsp; &nbsp; DI 방식을 적용해서 만들었다고 해보자. 모든 DAO는 생성 시점에 ConnectionMaker 타입의 오브젝트를 컨테이너로부터 제공받는다. 구체적인 사용 클래스 이름은 컨테이너가 사용할 설정정보에 들어 있다. 이를 서버에 배포할 때는 어떤 DAO 클래스와 코드도 수정할 필요가 없다. 단지 서버에서 사용할 DaoFactory를 수정해주기만 하면 된다. 

### 1.7.5 메소드를 이용한 의존관계 주입
* 수정자 메소드를 이용한 주입
	* Setter 메소드는 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도로 주로 사용된다. 수정자 메소드는 외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다가 내부의 ㅔㅁ소드에서 사용하게 하는 DI 방식에서 활용하기에 적당하다. 
* 일반 메소드를 이용한 주입
	* 수정자 메소드처럼 set으로 시작해야 하고 한 번에 한 개의 파라미터만 가질 수 있다는 제약이 싫다면 여러 개의 파라미터를 갖는 일반 메소드를 DI용으로 사용할 수도 있다. 
&nbsp; &nbsp; 스프링은 전통저긍로 메소드를 이용한 DI 방법 중에서 수정자 메소드를 가장 많이 사용해왔다. XML을 사용하는 경우에는 자바빈 규약을 따르는 수정자 메소드가 가장 사용하기 편리하다. 

## 1.8 XML을 이용한 설정
&nbsp; &nbsp; XML은 단순한 텍스트 파일이기 때문에 다루기 쉽다. 또, 쉽게 이해할 수 있으며 컴파일과 같은 별도의 빌드 작업이 없다는 것도 장점이다. 환경이 달라져서 오브젝트의 관계가 바뀌는 경우에도 빠르게 변경사항을 반영할 수 있다. 스키마나 DTD를 이용해서 정해진 포맷을 따라 작성됐는지 손쉽게 확인할 수도 있다. 

### 1.8.1 XML 설정
&nbsp; &nbsp; 스프링의 애플리케이션 컨텍스트는 XML에 담긴 DI 정보를 활용할 수 있다. DI 정보가 담긴 XML 파일은 \<beans\>를 루트 엘리먼트로 사용한다. 하나의 @Bean 메소드를 통해 얻을 수 있는 빈의 DI 정보는 다음 세 가지다.
1. 빈의 이름
2. 빈의 클래스
3. 빈의 의존 오브젝트 

#### XML의 의존관계 주입 정보
&nbsp; &nbsp; 프로퍼티 이름이나 빈의 이름은 인터페이스 이름과 다르게 정해도 상관없다. 의미를 좀 더 잘 드러낼 수 있는 이름이 있다거나, 같은 이름이 중복되는 상황이라면 적절한 ㅈ다른 이름을 부여해주자. 빈의 이름을 바꾸는 경우 그 이름을 참조하는 다른 빈의 \<property\> ref 애트리뷰트의 값도 함께 변경해줘야 한다. 

### 1.8.2 XML을 이용하는 애플리케이션 컨텍스트
&nbsp; &nbsp; XML에서 빈의 의존관계 정보를 이용하는 IoC/DI 작업에는 GenericXmlApplicationContext를 사용한다. 생성자 파라미터로 XML 파일의 클래스패스를 지정해주면 된다. XML 설정파일은 클래스 패스 최상단에 두면 편하다. 

### 1.8.3 DataSource 인터페이스로 변환
#### DataSource 인터페이스 적용
&nbsp; &nbsp; 일반적으로 DataSource를 구현해서 DB 커넥션을 제공하는 클래스를 만들 일은 거의 없다. 이미 다양한 방법으로 DB연결과 풀링기능을 갖춘 많은 DataSource 구현 클래스가 존재하고, 이를 가져다 사용하면 충분하기 때문이다. 대부분의 DataSource 구현 클래스는 DB의 종류나 아이디, 비밀번호 정도는 DataSource 구현 클래스를 다시 만들지 않고도 지정할 수 있는 방법을 제공한다. 

### 1.8.4 프로퍼티 값의 주입
#### 값 주입
&nbsp; &nbsp; 다른 빈 오브젝트의 레퍼런스가 아닌 단순 정보도 오브젝트를 초기화하는 과정에서 수정자 메소드에 넣을 수 있다. 클래스 외부에서 DB 연결정보와 같이 변경 가능한 정보를 설정해줄 수 있도록 만들기 위해서다. 텍스트나 단순 오브젝트 등을 수정자 메소드에 넣어주는 것을 스프링에서는 '값을 주입한다'고 말한다. 일종의 DI라고 볼 수 있다.
#### value 값의 자동 변환 
&nbsp; &nbsp; 스프링이 프로퍼티의 값을 수정자 메소드의 파라미터 타입을 참고로 해서 적절한 형태로 변환해주기 때문이다. 스프링은 value에 지정한 텍스트 값을 적절한 자바 타입으로 변환해준다. 

### 1.9 정리
&nbsp; &nbsp; 스프링이란 '어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크'라는 사실을 꼭 기억해두자. 스프링의 관심은 오브젝트와 그 관계다. 오브젝트를 어떻게 설계하고, 분리하고, 개선하고, 어떤 의존관계를 가질지 결정하는 일은 스프링이 아니라 개발자의 역할이며 책임이다. 스프링은 단지 원칙을 잘 따르는 설계를 적용하려고 할 때 필연적으로 등장하는 번거로운 작업을 편하게 할 수 있도록 도와주는 도구일 뿐임을 잊지 말자. 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYzMDE4MDU4Ml19
-->