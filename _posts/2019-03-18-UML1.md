---
layout: post
title:  "UML Distilled 스터디 1주차 (1장, 2장)"
date:   2019-03-18 09:00:00
author: Mintak OH
categories: UML
tags: UML study
---

# 1장. UML 소개
## UML이란 무엇인가?
* UML(Unified Modeling Language)은 그래픽 표기법(graphical notaion)의 집합으로, 단일 메타모델(meta-model)을 기초로 하고 있다.
* 객체 지향(object-oriented) 방식을 사용하여 구축하는 소프트웨어 시스템을 표현하고 설계하는 것을 도와준다.
* OMG(Object Management Group)에 의해서 관리되는 비교적 자유로운 표준이다.

## UML을 사용하는 방법
1. 스케치(sketch) - 선택성
    * 아이디어와 대안에 대한 이사 소통을 돕는게 목적이다.
    * 상당히 자유롭고 동적이므로, 빠른 시간에 혀력해서 작성할 필요가 있다. 
    * 완전성보다 전달성이 요구되는 문서에서도 스케치를 사용한다. 
2. 청사진(blueprint) - 완전성
    * 설계 시 생길 수 있는 의문에 대한 모든 답을 얻을 수 있을 정도로 설계가 완전해야 한다.
    * 모든 부분을 상세히 보여 줄 수도 있고, 특정한 부분만을 보여 줄 수도 있다. 
    * 역공학에서의 목적은 코드에 대한 상세한 정보를 문서로 만들어 내거나 그래픽 브라우저상에 보여 주기 위한 것이다.
    * 상세한 부분까지 다루어야 하므로 스케치보다 훨씬 더 복잡한 툴을 사용한다. (CASE 툴)
3. 프로그래밍 언어(programming language)
    * 개발자가 UML 다이어그램을 그리면 바로 실행 가능한 코드로 컴파일 된다. 
    * 순공학이나 역공학이라는 용어가 의미 없어진다. UML과 소스 코드가 같은 것이기 때문이다. 

셋 중에 가장 보편적인 것은 스케치로 생각하는 것이다.

### 모델 위주 아키텍처와 실행 가능한 UML
* MDA(Model Driven Architecture): UML을 프로그래밍 언어로 사용하기 위한 표준 접근 방법이다. 
    * 플랫폼 독립 모델(PIM: Platform Independent Model)
    * 플랫폼 종속 모델(PSM: Platform Specific Model)
    * 툴을 이용해서 PIM을 PSM으로 전환할 수 있다. 또 다른 툴을 PSM에 적용해서 해당 플랫폼에 대한 코드를 생성한다.

###  UML을 바라보는 관점
* 소프트웨어 관점
    *  UML의 속성이 소프트웨어 시스템의 구성 요소에 아주 잘 대응된다. UML을 사용한다는 것은 해당되는 소프트웨어 요소를 표현하는 것이 된다. 
* 개념적인 관점
    *  UML은 관심 있는 도메인의 개념을 설명한 것이다. 소프트웨어 시스템의 구성 요소에 대해서 언급하기보다는 특정 도메인에 대해서 이야기하는 데 필요한 용어 사전을 구축하는 것이다. 

## 표기법과 메타모델
* 표기법
    * 모델에서 볼 수 있는 그래픽 표현들을 말한다. 모델링 언어의 구문(syntax)에 해당한다.
    * 클래스 다이어그램 표기법은 항목과 개념, 클래스, 연관, 다중성 등을 어떻게 표현할 것인지 정의한다.
    * 대부분의 그래픽 모델링 언어는 엄밀성이 매우 떨어진다. 
    * 공식적인 정의보다는 직관에 호소한다. 
    * 비공식적일지라도 많은 사람들은 여전히 유용하게 생각한다.
* 메타모델
    * 유용성을 잃지 않으면서 더 견고해질 수 있는 방법이다.
    * 언어의 개념을 정의하는 다이어그램을 말하며 주로 클래스 다이어그램이다. 
    * ![이미지](https://raw.githubusercontent.com/mintakoh/mintakoh.github.io/master/assets/uml/1/image1.png)<br/>*그림 1.1 UML 메타모델 일부*
    * 모델링 표기법을 사용하는 사람들에게 얼마나 영향을 주는가?
        * 스케치를 하는 사람은 별로 상관하지 않는다.
        * 청사진을 만드는 사람들은은 좀 더 영향을 받는다.
        * 프로그래밍 언어로 사용하는 사람들에게는 매우 중요하다. 추상적인 구문을 정의하기 때문이다.

## UML 다이어그램
*표 1.1 UML의 공식 다이어그램 형식*

| 다이어그램 | 책의 장 | 용도 | 유래 |
| --- | --- | --- | --- |
| 액티비티<br/>(Activity) | 11 | 순차 행동과 병렬 행동 | UML 1 |
| 클래스<br/>(Class) | 3, 5 | 클래스, 특성, 관계 | UML 1 |
| 커뮤니케이션<br/>(Communication) | 12 | 연결에 중점을 둔 객체 간의 교류 | UML 1의 협력 다이어그램 |
| 컴포넌트<br/>(Component) | 12 | 컴포넌트의 구조와 연결 | UML 1 |
| 복합 구조<br/>(Composite structure) | 13 | 실행 시의 클래스를 분해 | UML 2에서 처음 소개됨 |
| 배치<br/>(Deployment) | 8 | 노드에 대한 아티팩트의 배치 | UML 1 |
| 교류 개요<br/>(Interaction overview) | 16 | 시퀀스 다이어그램과 액티비티 다이어그램의 혼합 | UML 2에서 처음 소개됨 |
| 객체<br/>(Object) | 6 | 인스턴스 구성의 예 | UML 1에 비공식적으로 사용 |
| 패키지<br/>(Package) | 7 | 컴파일 시으 ㅣ계층적 구조 | UML 1에 비공식적으로 사용 |
| 시퀀스<br/>(Sequence) | 4 | 순서에 중점을 둔 객체 간의 교류 | UML 1 |
| 상태 기계<br/>(State machine) | 10 | 객체가 살아 있는 동안 이벤트에 의해서 어떻게 변화되는가 | UML 1 |
| 타이밍<br/>(Timing) | 17 | 타이밍에 중점을 둔 객체 간의 교류 | UML 2에서 처음 소개됨 |
| 유스 케이스<br/>(Use case) | 9 | 사용자가 시스템과 어떻게 교류하는가 | UML 1 |

* ![image.png](/files/2435507432126300532)<br/>*그림 1.2 UML 다이어그램 타입의 분류*

##  UML은 충분하지 못하다
* UML은 필요한 다이어그램들을 모두 포함하고 있는 것은 절대로 아니다. 
* 장소에 따라 필요한 다이어그램은 다를 수 있으며, 목적에 맞는 것이 없다면 다른 다이어그램을 쓰면 된다.
    * 플로우 다이어그램
        * 화면이 의미하는 것에 대한 아주 개략적인 정의뿐이고, UML에는 이것과 비슷한 것이 없다. 
        * ![image.png](/files/2435510762239534884)<br/>*그림 1.3 wiki의 일부에 대한 비공식 화면 다이어그램 플로우*
    * 결정표
        * 복잡한 논리 조건을 나타내는 좋은 방법이다.
        * 액티비티 다이어그램으로도 나타낼 수 있지만, 표가 더 함축적이며 확실하다.
        * ![image.png](/files/2435515362523540210)<br/>*표 1.2 결정표*


# 2장. 개발 공정

## 반복 공정과 폭포수 공정
* 폭포수 공정(Waterfall style)
    * 액티비티 기준으로 프로젝트를 나눈다. 
    * 예를 들어 1년 길이의 프로젝트를 2개월의 분석, 4개월의 설계, 3개월의 개발, 3개월의 테스트로 나눌 수 있다.
    * 각 단계 사이에 어떤 형태의 공식 산출물이 있다. 
    * 종종 앞 단계로 돌아가는 경우도 있다. -> 가능한 최소화해야 한다.
* 반복 공정
    * 프로젝트를 기능의 부분 집합으로 나눈다.
    * 1년을 3개월의 반복으로 나눈다.
        * 첫 반복 때에 개발 사이클(분석, 설계, 개발, 테스트)를 진행한다.
        * 첫 반복이 끝나면 필요한 기능의 1/4를 제공하는 시스템을 가지게 된다.
    * 실제로 시작하기 전에 일정 형태으 ㅣ탐색 액티비티가 있다. 
    * 반복이 모두 끝난 시점에서 마지막으로 버그를 없앨 수 있는 안정화 기간이 필요하다. 
    * 일반적인 고민은 재작업 문제이다.
        * 이후의 반복 기간에 재작업을 해야하고 기존 코드를 삭제하게 된다.
        * 재작업을 도와주는 방법
            * 자동 회귀 테스트
            * 리팩토링
            * 연속적 통합
### 반복 공정과 폭포수 공정의 혼합
* 단계별 출시(Staged delivery)
    * 분석과 개략적인 설계는 폭포수 방식, 개발과 테스트는 반복 개발로 나누어 진행한다.

## 예측 계획법과 적응 계획법
* 폭포수 개발 방식이 계속 사용되는 이유는 예측 가능성을 기대하기 때문이다.
* 예측 계획법
    * 앞으로 어떤 것들을 해야 하는지 더 잘 알기 위해서 프로젝트 초기에 예측한다. 
    * 예측 계획법을 사용하면 프로젝트는 두 단계로 나뉘어진다.
        * 계획을 제안하는 것이며 예측하기 힘들다.
        * 계획이 자리를 잡았기 때문에 훨씬 더 예측하기가 쉽다. 
    * 대부분 소프트웨어 프로젝트에서 후반부에 요구사항이 변경되는 **요구 사항 흔들기**를 경험하게 된다. 
    * 고정 비용 / 고정 범위 계약을 맺을 수 있다. 
    * 어떤 공정에도 사용할 수 있지만, 폭포수 방법 또는 단계별 출시 접근 방법에 더 쉽게 적용된다.
* 적응 계획법
    * 예측 가능성이라는 환각으로 자신을 속이는 대신, 끊임없는 변화의 현실을 직시하고 소프트웨어 프로젝트에서 변경은 불가피하다고 간주하는 계획법이다. 
    * 고정 비용 / 가변 범위이다. 
    * 반복 공정이 필요하다.  

## 애자일 프로세스
* 애자일 프로세스의 종류
    * 익스트림 프로그래밍
    * Scrum
    * FDD
    * Crystal
    * DSDM
* 애자일 프로세스는 본질적으로 아주 적응적인 방법론이다.
* 아주 인간 지향적인 공정이다.
* 문서에 크게 집중하지 않기 때문에 청사진을 그리는 용도로 UML을 사용하는 것을 쓸데없는 것으로 여긴다. 
* 정해진 형식이란 변경을 힘들게 하며 능력있는 사람들의 성향에 맞지 않는다고 생각한다.
* 가벼움이 특징으로 여겨진다. 

##  RUP(Rational Unified Process)
* 공정을 이야기할 때 필요한 용어사전과 느슨한 구조를 제공하는 공정 프레임워크이다. 
* 가장 먼저 해야할 일은 개발 사례를 선택하는 것이다.
1. 개념화 단계 
2. 상세화 단계 
3. 구축 단계 
4. 전이 단계

## 공정을 프로젝트에 적용하기
* 소프트웨어 개발에 사용하게 되는 방법은 많은 요인에 의해서 결정된다.
    * 시스템의 종류, 사용하려고 하는 기술, 팀의 크기와 구성, 위험 요소의 특성, 실패의 결과, 팀의 일하는 스타일, 회사의 문화 등
        * 모든 프로젝트에 맞는 만능 공정은 없다!
1. 프로젝트를 살펴보고 어떤 공정들이 맞을 것 같은지를 고려하는 것이다.
2. 공정을 어떻게 변화시켜야 프로젝트에 맞을지를 고려해야 한다. 
    * 신중하게 해야한다.
    * 어떻게 동작하는지 알게 될 때까지 공정을 사용해서 몇 번의 반복을 수행해 보는 것이 도움이 된다.
3. 시작하게 되면 공정을 믿어야 한다.
    * 공정을 수행하면서 배울 수 있다. 
    * 반복 개발의 큰 장점 중 하나는 공정을 자주 개선할 수 있도록 지원한다는 것이다.
4. 매 반복이 끝날 때, 반복 돌아보기를 수행한다.
    1. 유지할 것: 진행이 잘 되어서 계속해서 하려 하는 것들
    2. 문제점: 잘 되지 않은 부분
    3. 시도할 것: 공정을 개선하기 위해 변화시킬 것들

## UML을 공정에 적용하기
### 요구 사항 분석
* 요구 사항 분석의 액티비티는 소프트웨어의 사용자와 고객들이 시스템이 어떤 것들을 해 주기를 원하는지 파악하기 위해서 노력하는 것이다.
    * 유스 케이스: 사람들이 시스템과 어떻게 상호 작용을 하는지 보여준다.
    * 클래스 다이어그램: 도메인의 정확한 어휘를 구성하는 좋은 방법이 될 수 있다.
    * 액티비티 다이어그램: 소프트웨어와 사람의 행동이 어떻게 상호 작용을 하는지를 보임으로써 조직의 워크플로우를 나타낼 수 있다. 유스 케이스의 관계를 보이며 복잡한 유스 케이스가 어떻게 동작하는지를 자세히 보여 줄 수 있다.
    * 상태 다이어그램: 어떤 개념이 다양한 상태와 그 상태를 변경하는 이벤트로 구성되어 흥미로운 생명 주기를 가지고 있을 때 유용하다.
* 사용자와 고객과 대화하는 것이 가장 중요하다.

### 설계
* 더 기술적인 표현, 더 많은 표기법, 더 정확하게 표기해야 한다.
    * 클래스 다이어그램: 이것은 소프트웨어 내의 클래스와 이 클래스들이 서로 어떻게 연관되는지를 보여준다.
    * 시퀀스 다이어그램: 유스 케이스로부터 가장 중요하고 흥미로운 시나리오를 찾아내고, CRC 카드나 시퀀스 다이어그램을 사용하여 소프트웨어에서 무엇이 일어나는지를 알아내는 것이 좋은 접근 방법이다.
    * 패키지 다이어그램
    * 상태 다이어그램
    * 배치 다이어그램
* 폭포수 기법을 사용한다면, 각 단계의 부분으로서 다이어그램과 액티비티를 수행해야 한다. 
    * 단계 마지막에서의 문서들에는 보통 해당 액티비티에 대한 적절한 UML 다이어그램이 포함된다. 
    * 일반적으로 폭포수 기법에서는 UML을 청사진으로서 사용한다고 가정한다. 
    * 반봅 스타일에서는 UML이 청사진이나 스케치로 사용될 수 있다. 

### 문서화
* 소프트웨어를 개발한 후에는, 한 일을 문서화하기 위해서 UML을 사용할 수 있다. 
* 시스템의 종합적인 이해를 하는 데에 UML 다이어그램이 도움이 된다.
* 패키지 다이어그램
    * 시스템에 대한 좋은 논리적인 로드 맵
* 클래스 다이어그램
    * 그래픽으로 나타낸 목차 같은 것이다.
* 교류 다이어그램
* 상태 기계 다이어그램
    * 행동이 꽤 복잡한 경우에만 수행한다.
* 액티비티 다이어그램
    * 복잡한 알고리즘이 있다면 사용한다.
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzODk3Mzg1NjFdfQ==
-->