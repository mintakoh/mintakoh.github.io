---
layout: post
title:  "토비의 스프링 1장(작성중)"
date:   2019-01-20 18:40:00
author: Mintak OH
categories: 토비의스프링
tags: spring java toby
---

# 1장. 오브젝트와 의존관계
 &nbsp; &nbsp; 스프링은 자바를 기반으로 한 기술이다. 자바에서 가장 중요하게 가치를 두는 것은 객체지향 프로그래밍이 가능한 언어라는 점이다. 스프링의 핵심 철학은 자바 엔터프라이즈 기술의 혼란 속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고, 그로부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이다. 
 &nbsp; &nbsp;  객체지향 설계의 기초와 원칙을 비롯해서, 다양한 목적을 위해 재활용 가능한 설계 방법인 디자인 패턴, 좀 더 깔끔한 구조가 되도록 지속적으로 개선해나가는 작업인 리팩토링, 오브젝트가 기대한 대로 동작하고 있는지를 효과적으로 검증하는 데 쓰이는 단위 테스트와 같은 오브젝트 설계와 구현에 관한 여러 가지 응용 기술과 지식이 요구된다. 
 
## 1.1 초난감 DAO
### 1.1.1 User
 &nbsp; &nbsp; 사용자 정보를 저장할 때는 자바빈 규약을 따르는 오브젝트를 이용하면 편리하다. 
* 자바빈
    자바빈(JavaBean)은 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말한다. JSP 빈, EJB와 같은 표준 기술과 자바빈 스타일의 오브젝트를 사용하는 오픈소스 기술을 통해 계속 이어져 왔다.
	*	디폴트 생성자: 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 리플렉션을 이용해 오브젝트를 생성하기 때문이다.
	*	프로퍼티: 자바빈이 노출하는 이름을 가진 속성이다. setter와 getter를 이용해 수정 또는 조회할 수 있다. 

### 1.1.2 UserDao
  &nbsp; &nbsp;사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스다. 사용자 정보를 관리하는 DAO이고, 사용자 정보의 등록, 수정, 삭제와 각종 조회 기능을 만들어야 한다. 
* 동작 확인 방법
	* DAO의 기능을 사용하는 웹 애플리케이션을 만들어 서버에 배치하고 사용해 보는 것이다. (부담이 너무 크다.)

### 1.1.3 main()을 이용한 DAO 테스트 코드
 &nbsp; &nbsp;기능을 검증하고자 할 때 사용할 수 있는 가장 간단한 방법은 오브젝트 스스로 자신을 검증하도록 만들어주는 것이다. 테스트 코드가 실패했다면 DB설정과 Connection 정보, 테이블 등록 여부 등을 확인해본다. 사용할 DB의 드라이버가 클래스패스에 있어야 하는 것도 잊으면 안된다. 

## 1.2 DAO의 분리
### 1.2.1 관심사의 분리
 &nbsp; &nbsp; 객체지향 기술은 흔히 실세계를 최대한 가깝게 모델링해낼 수 있기 때문에 의미가 있다고 여겨진다. 하지만 그보다는 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는 데 더 의미가 있다. 
  &nbsp; &nbsp; 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일아난다는 뜻이다. 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 점이다. 변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다. 즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다. 

### 1.2.2 커넥션 만들기의 추출
 &nbsp; &nbsp; DB 커넥션을 가져오는 코드가 여기저기에 계속 중복돼서 나타날 것이다. 하나의 관심사가 방만하게 중복되어 있고, 여기저기 흩어져 있어서 다른 관심의 대상과 얽혀 있으면, 변경이 일어날 때 엄청난 고통을 일으키는 원인이 된다. 
#### 변경사항에 대한 검증: 리팩토링과 테스트
 * 리팩토링
	 * 리팩토링은 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. 리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다. 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이해지고, 견고하면서도 유연한 제품을 개발할 수 있다. 

### 1.2.3 DB 커넥션 만들기의 독립
#### 상속을 통한 확장
 &nbsp; &nbsp; 메소드의 구현 코드를 제거하고 추상 메소드로 만든다. 기존에는 같은 클래스에 다른 메소드로 분리됐던 DB 커넥션 연결이라는 관심을 이번에는 상송을 통해 서브클래스로 분리해버리는 것이다. 
  &nbsp; &nbsp; 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 **템플릿 메소드 패턴** 이라고 한다.  이는 스프링에서 애용되는 디자인 패턴이다. 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴** 이라고 부르기도 한다. 

* 디자인 패턴
	* 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말하낟. 디자인 패턴은 주로 객체지향 설계에 관한 것이고, 대부분 객체 지향적 설계 원칙을 이용해 문제를 해결한다. 

* 템플릿 메소드 패턴
	* 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다. 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다. 슈퍼클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다. 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 **훅 메소드**라고 한다. 

* 팩토리 메소드 패턴
	* 슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있따. 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 **팩토리 메소드**라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 **팩토리 메소드 패턴**이라고 한다. 
 &nbsp; &nbsp; 이 방법은 상속을 사용했다는 단점이 있다. 상속 자체는 간단해 보이고 사용하기도 편리하게 느껴지지만 사실 많은 한계점이 있다. 자바는 클래스의 다중상소긍ㄹ 허용하지 않는다. 또 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다는 것이다. 

## 1.3 DAO의 확장
 &nbsp; &nbsp; 관심사에 따라서 분리한 오브젝트들은 제각기 독특한 변화의  특징이 있다. 변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다. 관심사가 바뀌면 그때 변경이 일어난다. 
  &nbsp; &nbsp; 추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서다. 여전히 상속이라는 방법을 사용했다는 사실이 불편하다. 
### 1.3.1 클래스의 분리
 &nbsp; &nbsp; 관심사가 다르고 변화의 성격이 다른 것을 독립시키면서 동시에 손쉽게 확장할 수 있는 방법을 알아보자. 다르게 변할 수 있는 관심사를 ㅜㅂㄴ리하는 작업을 점진저긍로 진행해왔다. 처음에는 독립된 메소드를 만들어서 분리했고, 다음에는 상하위 클래스로 분리했다. 서브클래스가 아니라 아예 별도의 클래스에 담는 방법으로 클래스를 분리한다. 
  &nbsp; &nbsp; 이 방법으로 클래스를 분리하면 상속을 통해 DB 커넥션 기능을 확장해서 사용하던 것이 다시 불가능해졌다. 클래스를 분리한 경우에도 상속을 이용했을 때와 마찬가지로 자유로운 확장이 가능하게 하려면 두 가지 문제를 해결해야 한다.
   * makeNewConnectino()을 사용해 DB 커넥션을 가져오게 했는데, 다른 프로젝트에서 openConnetion()이라는 이름의 메소드를 사용하면 UserDao 내에 있는 코드를 다 변경해야 한다. 
   * DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다는 점이다. 

### 1.3.2 인터페이스의 도입
&nbsp; &nbsp; 클래스를 분리하면서도 이런 문제를 해결할 수 없을까? 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것이다. 인터페이스는 자신을 구현한 클래스에 대해 구체적인 정보는 모두 감춰버린다. 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다. 
&nbsp; &nbsp; 인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이다. 따라서 인터페이스에는 어떻게 하겠다는 구현 방법은 나타나 있지 않다. 

### 1.3.3 관계설정 책임의 분리
&nbsp; &nbsp; UserDao 변경 없이는 DB커넥션 기능의 확장이 자유롭지 못한데, 그 이유는 UserDao 안에 분리되지 않은, 또 다른 관심사항이 존재하고 있기 때문이다. UserDao가 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지를 결정하는 것에 관심사를 담고 있다. 
&nbsp; &nbsp; 클래스 사이에 관계가 만들어진다는 것은 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻이다. 클래스가 아니라 오브젝트와 오브젝트 사이의 관계를 설정해줘야 한다. 오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다. 
&nbsp; &nbsp; 외부에서 만든 오브젝트를 전달받으려면 메소드 파라미터나 생성자 파라미터를 이용하면 된다. 이때 파라미터의 타입을 전달받을 오브젝트의 인터페이스로 선언해뒀다고 해보자, 이런 경우 파라미터로 전달되는 오브젝트의 클래스는 해당 인터페이스를 구현하기만 했다면 어떤 것이든지 상관없다. 

### 1.3.4 원칙과 패턴
#### 개방 폐쇄 원칙
&nbsp; &nbsp; 

## 1.4 제어의 역전(IoC)
### 1.4.1 오브젝트 팩토리
### 1.4.2 오브젝트 팩토리의 활용
### 1.4.3 제어권의 이전을 통한 제어관계 역전

## 1.5 스프링의 IoC
### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
### 1.5.2 애플리케이션 컨텍스트의 동작방식
### 1.5.3 스프링 IoC의 용어 정리

## 1.6 싱글톤 레지스트리와 오브젝트 스코프
### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
### 1.6.2 싱글톤과 오브젝트의 상태
### 1.6.3 스프링 빈의 스코프

## 1.7 의존관계 주입(DI)
### 1.7.1 제어의 역전(IoC)과 의존관계 주입
### 1.7.2 런타임 의존관계 설정
### 1.7.3 의존 관계 검색과 주입
### 1.7.4 의존관계 주입의 응용
### 1.7.5 메소드를 이용한 의존관계 주입

## 1.8 XML을 이용한 설정
### 1.8.1 XML 설정
### 1.8.2 XML을 이용하는 애플리케이션 컨텍스트
### 1.8.3 DataSource 인터페이스로 변환
### 1.8.4 프로퍼티 값의 주입
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM3OTk3NDI0N119
-->
